<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"
        integrity="sha256-+5R1zw/Tcxp82QhhfAJlicTeM4LCzFxp6EvsZW3V9bE=" crossorigin="anonymous"></script>
    <script src="https://s3.amazonaws.com/coursetro/stuff/mtl.js"></script>
    <script src="https://s3.amazonaws.com/coursetro/stuff/obj.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.4/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="https://raw.githubusercontent.com/mrdoob/three.js/master/src/math/MathUtils.js"></script>
    <script>

        // Create the Three.js Scene
        var scene = new THREE.Scene();

        // Create a new Perspective Camera
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.z = 30;
        camera.position.y = 25;

        // Create a Full Screen WebGL Renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor("#000000");
        renderer.setSize(window.innerWidth, window.innerHeight);

        document.body.appendChild(renderer.domElement);

        // Make sure the project is responsive based on window resizing
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        })

        // Add a light
        // var light = new THREE.PointLight(0xFFFFFF, 1.4, 10)
        // light.position.set(0, 15, 15);
        // scene.add(light);
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(100, 1000, 100);

        spotLight.castShadow = true;

        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;

        spotLight.shadow.camera.near = 500;
        spotLight.shadow.camera.far = 4000;
        spotLight.shadow.camera.fov = 30;

        scene.add(spotLight);


        var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
        scene.add(light);

        // var grid = new THREE.GridHelper(100, 10);
        // scene.add(grid);

        var material = new THREE.LineBasicMaterial({ color: 0x0000ff });

        var points = [];
        points.push(new THREE.Vector3(-16, 0, 0));
        points.push(new THREE.Vector3(0, 10, 0));
        points.push(new THREE.Vector3(16, 0, 0));

        var geometry = new THREE.BufferGeometry().setFromPoints(points);
        var line = new THREE.Line(geometry, material);
        scene.add(line);

        var points2 = [];
        points2.push(new THREE.Vector3(-30, 0, 0));
        points2.push(new THREE.Vector3(0, 20, 0));
        points2.push(new THREE.Vector3(30, 0, 0));

        var geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
        var line2 = new THREE.Line(geometry2, material);
        scene.add(line2);

        var points3 = [];
        points3.push(new THREE.Vector3(-40, 0, 0));
        points3.push(new THREE.Vector3(0, 30, 0));
        points3.push(new THREE.Vector3(40, 0, 0));

        var geometry3 = new THREE.BufferGeometry().setFromPoints(points3);
        var line3 = new THREE.Line(geometry3, material);
        scene.add(line3);


        var points4 = [];
        points4.push(new THREE.Vector3(-45, 0, 0));
        points4.push(new THREE.Vector3(0, 40, 0));
        points4.push(new THREE.Vector3(45, 0, 0));

        var geometry4 = new THREE.BufferGeometry().setFromPoints(points4);
        var line4 = new THREE.Line(geometry4, material);
        scene.add(line4);


        var points5 = [];
        points5.push(new THREE.Vector3(-50, 0, 0));
        points5.push(new THREE.Vector3(0, 50, 0));
        points5.push(new THREE.Vector3(50, 0, 0));

        var geometry5 = new THREE.BufferGeometry().setFromPoints(points5);
        var line5 = new THREE.Line(geometry5, material);
        scene.add(line5);


        var points6 = [];
        points6.push(new THREE.Vector3(-55, 0, 0));
        points6.push(new THREE.Vector3(0, 60, 0));
        points6.push(new THREE.Vector3(55, 0, 0));

        var geometry6 = new THREE.BufferGeometry().setFromPoints(points6);
        var line6 = new THREE.Line(geometry6, material);
        scene.add(line6);


        var points7 = [];
        points7.push(new THREE.Vector3(-58, 0, 0));
        points7.push(new THREE.Vector3(0, 70, 0));
        points7.push(new THREE.Vector3(58, 0, 0));

        var geometry7 = new THREE.BufferGeometry().setFromPoints(points7);
        var line7 = new THREE.Line(geometry7, material);
        scene.add(line7);

        // var length = 10, width = 100;

        // var shape = new THREE.Shape();
        // shape.moveTo(0, 0);
        // shape.lineTo(0, width);
        // shape.lineTo(length, width);
        // shape.lineTo(length, 0);
        // shape.lineTo(0, 0);

        // var extrudeSettings = {
        //     steps: 2,
        //     depth: 10,
        //     bevelEnabled: true,
        //     bevelThickness: 1,
        //     bevelSize: 1,
        //     bevelOffset: 0,
        //     bevelSegments: 1
        // };

        // var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        // var material = new THREE.MeshBasicMaterial({ color: 0x00eeee });
        // var mesh = new THREE.Mesh(geometry, material);
        // scene.add(mesh);

        var render = function () {
            requestAnimationFrame(render);
            // mesh.rotation.z += 0.01;
            // controls.update();
            // camera.position.z = 30;
            if (camera.position.z > 28) camera.position.z -= 0.01;
            else camera.position.z += 0.01

            renderer.render(scene, camera);
        }

        document.addEventListener('mousemove', function (e) {
            var mousecoords = getMousePos(e);
            moveJoint(mousecoords, line, 6);
            moveJoint(mousecoords, line2, 5);
            moveJoint(mousecoords, line3, 4);
            moveJoint(mousecoords, line4, 3);
            moveJoint(mousecoords, line5, 2);
            moveJoint(mousecoords, line6, 1);
            moveJoint(mousecoords, line7, 1);
        });


        // Call this to render the entire scene
        render();

        function getMousePos(e) {
            return { x: e.clientX, y: e.clientY };
        }

        function moveJoint(mouse, joint, degreeLimit) {
            let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
            gsap.to(joint.rotation, 5, { y: THREE.Math.degToRad(degrees.x), x: THREE.Math.degToRad(degrees.y), z: 0, ease: Expo.easeOut })
        }

        function getMouseDegrees(x, y, degreeLimit) {
            let dx = 0,
                dy = 0,
                xdiff,
                xPercentage,
                ydiff,
                yPercentage;

            let w = { x: window.innerWidth, y: window.innerHeight };

            // Left (Rotates neck left between 0 and -degreeLimit)
            // 1. If cursor is in the left half of screen
            if (x <= w.x / 2) {
                // 2. Get the difference between middle of screen and cursor position
                xdiff = w.x / 2 - x;
                // 3. Find the percentage of that difference (percentage toward edge of screen)
                xPercentage = (xdiff / (w.x / 2)) * 100;
                // 4. Convert that to a percentage of the maximum rotation we allow for the neck
                dx = ((degreeLimit * xPercentage) / 100) * -1;
            }

            // Right (Rotates neck right between 0 and degreeLimit)
            if (x >= w.x / 2) {
                xdiff = x - w.x / 2;
                xPercentage = (xdiff / (w.x / 2)) * 100;
                dx = (degreeLimit * xPercentage) / 100;
            }
            // Up (Rotates neck up between 0 and -degreeLimit)
            if (y <= w.y / 2) {
                ydiff = w.y / 2 - y;
                yPercentage = (ydiff / (w.y / 2)) * 100;
                // Note that I cut degreeLimit in half when she looks up
                dy = (((degreeLimit * 0.5) * yPercentage) / 100) * -1;
            }
            // Down (Rotates neck down between 0 and degreeLimit)
            if (y >= w.y / 2) {
                ydiff = y - w.y / 2;
                yPercentage = (ydiff / (w.y / 2)) * 100;
                dy = (degreeLimit * yPercentage) / 100;
            }
            return { x: dx, y: dy };
        }

    </script>
</body>

</html>