<!DOCTYPE html>
<html>

<head>
    <title>three.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
    <style>
        body {
            background-color: #000;
            color: #000;
            margin: 0;
            padding: 0;
        }

        a {
            color: #48f;
        }
    </style>
</head>

<body>

    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.js"></script>
    <script type="module">

        // import * as THREE from './build/three.module.js';

        import { TWEEN } from './jsm/libs/tween.module.min.js';
        // import { TrackballControls } from './jsm/controls/TrackballControls.js';
        // import { CSS3DRenderer, CSS3DSprite } from './jsm/renderers/CSS3DRenderer.js';

        // var camera, scene, renderer;
        // var controls;

        // var particlesTotal = 512;
        // var positions = [];
        // var objects = [];
        // var current = 0;

        // var randoms = [];

        // init();
        // animate();

        // function init() {

        //     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        //     camera.position.set(600, 400, 1500);
        //     camera.lookAt(0, 0, 0);

        //     scene = new THREE.Scene();
        //     initCubes(50);
        //     // var image = document.createElement('img');
        //     // image.addEventListener('load', function () {
        //     //     for (var i = 0; i < particlesTotal; i++) {
        //     //         var object = new CSS3DSprite(image.cloneNode());
        //     //         object.position.x = Math.random() * 4000 - 2000,
        //     //             object.position.y = Math.random() * 4000 - 2000,
        //     //             object.position.z = Math.random() * 4000 - 2000;
        //     //         scene.add(object);
        //     //         objects.push(object);
        //     //     }
        //     //     transition();
        //     // }, false);
        //     // image.src = 'textures/sprite.png';

        //     // Plane

        //     var amountX = 16;
        //     var amountZ = 32;
        //     var separation = 150;
        //     var offsetX = ((amountX - 1) * separation) / 2;
        //     var offsetZ = ((amountZ - 1) * separation) / 2;

        //     for (var i = 0; i < particlesTotal; i++) {

        //         var x = (i % amountX) * separation;
        //         var z = Math.floor(i / amountX) * separation;
        //         var y = (Math.sin(x * 0.5) + Math.sin(z * 0.5)) * 200;

        //         positions.push(x - offsetX, y, z - offsetZ);

        //     }

        //     // Cube

        //     var amount = 8;
        //     var separation = 150;
        //     var offset = ((amount - 1) * separation) / 2;

        //     for (var i = 0; i < particlesTotal; i++) {
        //         var x = (i % amount) * separation;
        //         var y = Math.floor((i / amount) % amount) * separation;
        //         var z = Math.floor(i / (amount * amount)) * separation;
        //         positions.push(x - offset, y - offset, z - offset);
        //     }

        //     // Random

        //     for (var i = 0; i < particlesTotal; i++) {
        //         positions.push(
        //             Math.random() * 4000 - 2000,
        //             Math.random() * 4000 - 2000,
        //             Math.random() * 4000 - 2000
        //         );
        //     }

        //     // Sphere

        //     var radius = 750;
        //     for (var i = 0; i < particlesTotal; i++) {
        //         var phi = Math.acos(- 1 + (2 * i) / particlesTotal);
        //         var theta = Math.sqrt(particlesTotal * Math.PI) * phi;
        //         positions.push(
        //             radius * Math.cos(theta) * Math.sin(phi),
        //             radius * Math.sin(theta) * Math.sin(phi),
        //             radius * Math.cos(phi)
        //         );
        //     }

        //     //


        //     var mouse = { x: 0, y: 0 };
        //     var cameraMoves = { x: 0, y: 0, z: -0.1, move: false, speed: 0.2 };

        //     function mouseMove(e) {
        //         console.log('moving')
        //         camera.position.x += Math.max(Math.min((e.clientX - mouse.x) * 0.01, cameraMoves.speed), -cameraMoves.speed);
        //         camera.position.y += Math.max(Math.min((mouse.y - e.clientY) * 0.01, cameraMoves.speed), -cameraMoves.speed);

        //         mouse.x = e.clientX;
        //         mouse.y = e.clientY;

        //     }
        //     window.addEventListener('mousemove', mouseMove, false);



        //     // renderer = new CSS3DRenderer();
        //     // renderer.setSize(window.innerWidth, window.innerHeight);
        //     // document.getElementById('container').appendChild(renderer.domElement);

        //     renderer = new THREE.WebGLRenderer({ alpha: true });
        //     renderer.setSize(window.innerWidth, window.innerHeight);
        //     document.body.appendChild(renderer.domElement);

        //     //

        //     // controls = new TrackballControls(camera, renderer.domElement);

        //     //

        //     window.addEventListener('resize', onWindowResize, false);

        // }

        // function onWindowResize() {

        //     camera.aspect = window.innerWidth / window.innerHeight;
        //     camera.updateProjectionMatrix();

        //     renderer.setSize(window.innerWidth, window.innerHeight);

        // }

        // function transition() {

        //     var offset = current * particlesTotal * 3;
        //     var duration = 2000;

        //     for (var i = 0, j = offset; i < particlesTotal; i++ , j += 3) {

        //         var object = objects[i];

        //         new TWEEN.Tween(object.position)
        //             .to({
        //                 x: positions[j],
        //                 y: positions[j + 1],
        //                 z: positions[j + 2]
        //             }, Math.random() * duration + duration)
        //             .easing(TWEEN.Easing.Exponential.InOut)
        //             .start();

        //     }

        //     new TWEEN.Tween(this)
        //         .to({}, duration * 3)
        //         .onComplete(transition)
        //         .start();

        //     current = (current + 1) % 4;

        // }

        // function animate() {

        //     requestAnimationFrame(animate);

        //     TWEEN.update();
        //     // controls.update();

        //     var time = performance.now();

        //     for (var i = 0, l = objects.length; i < l; i++) {

        //         var object = objects[i];
        //         var scale = Math.sin((Math.floor(object.position.x) + time) * 0.002) * 0.3 + 1;
        //         object.scale.set(scale, scale, scale);

        //     }

        //     renderer.render(scene, camera);

        // }

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        var renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var randoms = [];
        var mouse = { x: 0, y: 0 };
        var cameraMoves = { x: 0, y: 0, z: -0.1, move: false, speed: 0.2 };

        var particlesTotal = 512;
        var positions = [];
        var objects = [];
        var current = 0;

        initCubes(particlesTotal);

        // render();
        animate();

        function mouseMove(e) {

            camera.position.x += Math.max(Math.min((e.clientX - mouse.x) * 0.01, cameraMoves.speed), -cameraMoves.speed);
            camera.position.y += Math.max(Math.min((mouse.y - e.clientY) * 0.01, cameraMoves.speed), -cameraMoves.speed);

            mouse.x = e.clientX;
            mouse.y = e.clientY;

        }
        window.addEventListener('mousemove', mouseMove);

        function initCubes(n) {

            for (var i = 0; i < n; i++) {
                randoms[i] = makeRandom();
                createCube(randoms[i].x, randoms[i].y, randoms[i].z, randoms[i].width, randoms[i].height, randoms[i].depth);
            }//for

            // Plane

            var amountX = 16;
            var amountZ = 32;
            var separation = 50;
            var offsetX = ((amountX - 1) * separation) / 2;
            var offsetZ = ((amountZ - 1) * separation) / 2;

            for (var i = 0; i < particlesTotal; i++) {
                var x = (i % amountX) * separation;
                var z = Math.floor(i / amountX) * separation;
                var y = (Math.sin(x * 0.5) + Math.sin(z * 0.5)) * 200;
                positions.push(x - offsetX, y, z - offsetZ);
            }
            transition();

            // Cube
            var amount = 8;
            var separation = 150;
            var offset = ((amount - 1) * separation) / 2;
            for (var i = 0; i < particlesTotal; i++) {
                var x = (i % amount) * separation;
                var y = Math.floor((i / amount) % amount) * separation;
                var z = Math.floor(i / (amount * amount)) * separation;
                positions.push(x - offset, y - offset, z - offset);
            }

            // Random
            for (var i = 0; i < particlesTotal; i++) {
                positions.push(
                    Math.random() * 4000 - 2000,
                    Math.random() * 4000 - 2000,
                    Math.random() * 4000 - 2000
                );
            }

            // Sphere
            var radius = 750;
            for (var i = 0; i < particlesTotal; i++) {
                var phi = Math.acos(- 1 + (2 * i) / particlesTotal);
                var theta = Math.sqrt(particlesTotal * Math.PI) * phi;
                positions.push(
                    radius * Math.cos(theta) * Math.sin(phi),
                    radius * Math.sin(theta) * Math.sin(phi),
                    radius * Math.cos(phi)
                );
            }
        }

        function makeRandom() {

            var x = Math.floor(Math.random() * 20 - 10);
            var y = Math.floor(Math.random() * 20 - 10);
            var z = Math.floor(Math.random() * -50);

            // var width = Math.ceil(Math.random() * 6);
            // var height = Math.ceil(Math.random() * 6);
            var width = 15;
            var height = 15;
            var depth = 2;

            return { x: x, y: y, z: z, width: width, height: height, depth: depth };

        }   // makeRandom()

        function createCube(x, y, z, width, height, depth) {

            var geometry = new THREE.BoxGeometry(width, height, depth);

            var cube = new THREE.Mesh(geometry);
            scene.add(cube);
            cube.position.set(x, y, z);
            objects.push(cube);

        }//createCube()

        function render() {
            requestAnimationFrame(render);
            //camera.position.z += cameraMoves.z; 
            renderer.render(scene, camera);
        }// render()

        function transition() {

            var offset = current * particlesTotal * 3;
            var duration = 2000;

            for (var i = 0, j = offset; i < particlesTotal; i++ , j += 3) {

                var object = objects[i];

                new TWEEN.Tween(object.position)
                    .to({
                        x: positions[j],
                        y: positions[j + 1],
                        z: positions[j + 2]
                    }, Math.random() * duration + duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();

            }

            new TWEEN.Tween(this)
                .to({}, duration * 3)
                .onComplete(transition)
                .start();

            current = (current + 1) % 4;

        }

        function animate() {

            requestAnimationFrame(animate);

            TWEEN.update();
            // controls.update();

            var time = performance.now();

            for (var i = 0, l = objects.length; i < l; i++) {

                var object = objects[i];
                var scale = Math.sin((Math.floor(object.position.x) + time) * 0.002) * 0.3 + 1;
                object.scale.set(scale, scale, scale);

            }

            renderer.render(scene, camera);

        }

    </script>
</body>

</html>